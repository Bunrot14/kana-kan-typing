<!DOCTYPE html>
<html lang="ja">
<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-84N6PLRMJY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-84N6PLRMJY');
</script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta name="google-site-verification" content="ZqIqYlZDifbNwvYH5bcib3CigI-syrHrCMTkBAhal7c" />

  <title>かな漢タイピング｜静かに集中する長文タイピング練習</title>
 
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8332431277909692"
     crossorigin="anonymous"></script>
<!--adsenseのメタタグ-->
<meta name="google-adsense-account" content="ca-pub-8332431277909692">

  <meta name="description" content="哲学的で詩的な日本語文を使ったかな漢字交じりの長文タイピング練習サイト。無心で打鍵することで集中力を養い心を整える瞑想的な体験を。随時更新される創作文で、言葉とリズムの調和を楽しめます。" />
  <meta name="keywords" content="タイピング, 長文, かな漢字, 瞑想, 無心, 日本語, 練習, 哲学, 詩, ポエジー, タイピングサイト" />
  <meta name="author" content="Bunrot" />

  <meta property="og:title" content="かな漢タイピング｜静かに集中する長文タイピング練習" />
  <meta property="og:description" content="詩的で哲学的な日本語長文で、無心の打鍵。心を整えるタイピング体験を。" />
  <meta property="og:image" content="https://yourdomain.com/og-image.jpg" /> <meta property="og:url" content="https://bunrot14.github.io/kana-kan-typing/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="かな漢タイピング" />
  <meta name="twitter:description" content="哲学的で詩的な日本語長文で、無心の打鍵。心を整えるタイピング体験を。" />
  <meta name="twitter:image" content="https://yourdomain.com/og-image.jpg" />
  <style>
    * {
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
}


    body {
      font-family: 'Yu Gothic', sans-serif;
      background: #f5f5f5;
      padding: 2rem;
      line-height: 1.8;
    }

    h1 {
      text-align: center;
      margin-bottom: 1rem;
    }

    .problem-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 1rem;
      flex-wrap: wrap; /* ボタンが多すぎるときに折り返すように */
    }

    .problem-buttons button {
      padding: 0.5rem 1rem;
      background: #ccc;
      border: none;
      cursor: pointer;
      border-radius: 5px;
    }

    .problem-buttons button:hover {
      background: #aaa;
    }
    
    .problem-buttons button.active { /* 現在選択中の問題セットのボタンを強調 */
      background: #888;
      color: white;
    }

    #display,
    #typingArea {
      width: 65vw;
      font-size: 15px;
      border-radius: 8px;
    }

    #display {
      background-color: black;
      color: white;
      padding: 1rem;
      margin-bottom: 1rem;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      word-break: break-word;
      min-height: 100px; /* 文章量によって高さが変わるため最小高さを指定 */
    }

    #display span {
      white-space: pre;
    }

    .correct {
      background-color: #ccc !important;
      color: white !important;
    }

    .incorrect {
      color: rgb(0, 160, 199) !important;
    }

    .untyped {
      color: white !important;
    }

    #typingArea {
      width: 65vw;
    height: auto;
    min-height: 150px; /* 最小高さ */
    max-height: 600px; /* 最大高さ */
    overflow-y: auto; /* 内容が最大を超えたらスクロール */

      font-size: 15px;
      padding: 1rem;
      line-height: 1.5;
      resize: none;
      border-radius: 8px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      font-family: inherit;
    }

    #popup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border: 2px solid #888;
  padding: 1.5em;
  min-width: 300px;       /* 最小幅：小さい表示にも対応 */
  max-width: 90vw;        /* 最大幅：画面の90%まで広がる */
  width: fit-content;     /* 内容に応じて幅を調整 */
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
  z-index: 9999;
  font-family: "Yu Gothic", sans-serif;
  line-height: 1.5;
  word-break: break-word;
  white-space: normal;    /* 長文がちゃんと改行されるように */
}

#popup ul {
  padding-left: 1.5rem;
  list-style-type: none;
  margin: 1rem 0;
}

#popup ul li::before {
  content: "◆ ";
  color: #777;
}

#popupList li {
  margin-bottom: 0.6em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#archive-list {
  margin-top: 1rem;
  text-align: left;
}

.archive-entry {
  margin-bottom: 1rem;
}

.archive-entry p {
  font-weight: bold;
  margin-bottom: 0.5rem;
}

.archive-titles {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.archive-titles button {
  padding: 0.3rem 1rem;
  background: #ccc;
  border: none;
  cursor: pointer;
  border-radius: 5px;
  font-size: 14px;
}

.archive-titles button:hover {
  background: #aaa;
}

#archive-list a {
  text-align: left;
  margin-left: 0;
  display: inline-block;
  margin-top: 1rem;
  color: #007acc;
  text-decoration: none;
}

  </style>
  <style>
    /* ヘッダーに表示するメッセージのスタイル */
    .site-intro {
      font-size: 0.8em; /* 小さめの文字サイズ */
      color: #888; /* 優しいグレー */
      text-align: center; /* 中央揃え */
      margin: 1px 0; /* 上下のマージンで余裕を持たせる */
      font-family: 'Arial', sans-serif; /* 優しい雰囲気のフォント */
    }
  </style>
  
</head>
<body>
  <header style="display: flex; flex-direction: column; align-items: center;">
    <p class="site-intro">
      このサイトは静かに集中してタイピングの瞑想性を楽しむことと、漢字変換ありの実践的なタイピングスキルを向上させることを目的とした無償の学習サービスです。<br>
      言葉のリズムと流れに身を任せ、指先で紡ぐ文章が心を穏やかにし、思考を深めていく。<br>
      ここではただ速さを追い求めるのではなく、ひとつひとつの文字に心を込めてタイピングを楽しんでください。
    </p>

    <div class="problem-container" style="display: flex; justify-content: center; align-items: center; width: 100%; position: relative;">
      <div style="display: flex; flex-direction: column; align-items: flex-start; position: absolute; left: 0; padding-left: 1em;">
        <div class="problem-header" id="problem-header-date" style="font-size: 0.9em; color: #555; text-align: left; margin-top: 0; margin-bottom: 5px;">
          </div>
        
        <div style="display: block;">
          <div class="problem-buttons" id="problem-buttons">
            </div>
        </div>
      </div>
    
      <h1 style="text-align: center; margin: 0; padding: 0; margin-top: 20px; margin-bottom: 20px;">かな漢タイピング</h1>

    </div>
    
  </header>  

  <div id="display"></div>

  <textarea id="typingArea" placeholder="ここに全文を入力してください..."></textarea>

<section id="archive" style="margin-top: 2rem;">
  <h2>バックナンバー</h2>
  <div id="archive-list">
    </div>
  <div style="margin-top: 1rem; text-align: left;">
    <a href="archive.html" style="color: #007acc; text-decoration: none;">すべてのバッグナンバーはこちら</a>
  </div>
</section>

  

  <div id="popup">
    <ul id="popupList"></ul>
    <p>（Qキーで閉じる）</p>
  </div>

  <footer style="position: static; bottom: 0; width: 100%; text-align: center; font-size: 12px; padding: 1px; background: #f5f5f5; margin-top: 2rem;">
    <p style="margin: 0;">
      <a href="meditation_typing.html" style="color: #007acc; text-decoration: none;">瞑想的タイピングのすすめ</a>
      <br>
      練習用テキストはすべてフィクションであり、特定の思想、団体、個人を揶揄・批判する意図はありません。
      <br>
      <a href="terms.html" style="color: #007acc; text-decoration: none;">利用規約</a> |
      <a href="privacy.html" style="color: #007acc; text-decoration: none;">プライバシーポリシー</a> |
      <a href="contact.html" style="color: #007acc; text-decoration: none;">お問い合わせ</a>
    </p>
    <p style="margin: 0;">&copy; 2025 Bunrot's Typing Site. All Rights Reserved.</p>
    <p style="margin: 0;">運営者：Bunrot</p>
  </footer>
  
  

  <script>
  
  const display = document.getElementById("display");
  const typingArea = document.getElementById("typingArea");
  const popup = document.getElementById("popup");
  const popupList = document.getElementById("popupList");
  const problemHeaderDate = document.getElementById("problem-header-date");
  const problemButtonsContainer = document.getElementById("problem-buttons");

  let allEssays = []; // 全ての問題文テキストを格納する配列
  let archiveStructure = []; // 新しいバックナンバー情報の構造を格納する配列

  let currentEssayIndex = 0; // 現在表示している問題のessays配列でのグローバルインデックス
  let currentProblemSetStartIndex = 0; // 現在選択されている問題セットの開始インデックス
  let currentProblemSetNumProblems = 0; // 現在選択されている問題セットの問題数
  let startTime = null;

  async function loadTypingData() {
  try {
    const response = await fetch('typing_data.json'); // JSONファイルを非同期で取得
    if (!response.ok) {
      // fetchが成功しても、HTTPステータスがエラーを示す場合 (404 Not Found, 500 Internal Server Errorなど)
      throw new Error(`JSONファイルの読み込みに失敗しました。ステータス: ${response.status}`);
    }
    const jsonData = await response.json(); // レスポンスをJSONとしてパース

    // jsonDataが配列であることを確認 (typing_data.jsonのルートが配列なので)
    if (!Array.isArray(jsonData)) {
        throw new Error("JSONデータの形式が正しくありません。ルートは配列であるべきです。");
    }

    let currentIndex = 0;
    // JSONデータから allEssays と archiveStructure を構築
    jsonData.forEach(dailyEntry => {
      const titles = [];
      const dailyEssaysTexts = [];

      if (!dailyEntry.essays || !Array.isArray(dailyEntry.essays)) {
        console.warn(`日付 ${dailyEntry.date} の 'essays' 配列が見つからないか、形式が正しくありません。スキップします。`);
        return; // このdailyEntryをスキップして次に進む
      }

      dailyEntry.essays.forEach(essay => {
        titles.push(essay.title || "タイトルなし"); // titleがない場合のフォールバック
        dailyEssaysTexts.push(essay.text || ""); // textがない場合のフォールバック
      });

      archiveStructure.push({
        date: dailyEntry.date,
        titles: titles,
        essayStartIndex: currentIndex,
        numProblems: dailyEssaysTexts.length 
      });

      allEssays.push(...dailyEssaysTexts); // 個々の問題文テキストをallEssaysに追加
      currentIndex += dailyEssaysTexts.length;
    });

    // データ読み込みと処理が成功したらサイトの初期化処理を呼び出す
    initializeSite();

  } catch (error) {
    console.error("問題データの処理中にエラーが発生しました:", error);
    // ユーザーにエラーを通知するためのシンプルな表示
    document.body.innerHTML = `<p style="text-align:center; padding: 20px; font-size: 1.2em;">サイトのデータの読み込みに失敗しました。<br>お手数ですが、ページを再読み込みするか、しばらくしてから再度お試しください。<br><small>エラー詳細: ${error.message}</small></p>`;
  }
}

function initializeSite() {
  console.log("JSONデータが読み込まれ、データ構造が準備できました。");
  // console.log("allEssays:", allEssays);
  // console.log("archiveStructure:", archiveStructure); 

  if (archiveStructure.length > 0 && allEssays.length > 0) {
    // localStorageから選択された問題の情報を読み取る (これはステップ4で詳しく実装)
    const selectedProblemInfo = JSON.parse(localStorage.getItem('selectedTypingProblem'));
    if (selectedProblemInfo) {
      localStorage.removeItem('selectedTypingProblem'); // 読み取ったら削除
      setActiveProblemSet(selectedProblemInfo.setIndex);
      if (typeof selectedProblemInfo.essayIndexInSet !== 'undefined') {
          // essayIndexInSet があれば、それを使って特定の問題を表示
          // archiveStructure[selectedProblemInfo.setIndex].essayStartIndex と selectedProblemInfo.essayIndexInSet からグローバルインデックスを計算
          const globalEssayIndex = archiveStructure[selectedProblemInfo.setIndex].essayStartIndex + selectedProblemInfo.essayIndexInSet;
          setEssay(globalEssayIndex);
      }
    } else {
      // localStorageに情報がなければ、通常通り最新の問題セットを表示
      setActiveProblemSet(0); 
    }

    // バックナンバー表示を最新4件に絞る
    const recentArchives = archiveStructure.slice(0, 4); // 最新の4件を取得
    renderArchive(recentArchives); // 絞ったデータをrenderArchiveに渡す
  } else {
    console.error("問題データが空か、正しく読み込めませんでした。サイトの初期化をスキップします。");
    if (!document.querySelector('p[style*="データの読み込みに失敗しました"]') && !document.querySelector('p[style*="問題データがありません"]')) {
         document.body.innerHTML = `<p style="text-align:center; padding: 20px; font-size: 1.2em;">問題データの読み込みに問題があるため、サイトを表示できません。</p>`;
    }
  }
}

function setActiveProblemSet(problemSetIndex) {
  // const problemSet = archiveData[problemSetIndex]; // ← 古い行 (コメントアウトまたは削除)
  const problemSet = archiveStructure[problemSetIndex]; // ← 新しい行
  if (!problemSet) {
    console.error("指定された問題セットが見つかりません:", problemSetIndex);
    // エラー発生時はここで処理を中断するか、適切なフォールバックを行う
    // 例えば、最初の問題セットを表示する、エラーメッセージを出すなど
    if (archiveStructure.length > 0) {
        // archiveStructureが空でなければ、最初の問題セットを試みる
        // ただし、無限ループにならないように注意が必要
        // ここでは単純にエラーログに留め、呼び出し元でケアする想定
    }
    return; 
  }

  currentProblemSetStartIndex = problemSet.essayStartIndex;
  currentProblemSetNumProblems = problemSet.numProblems;

  const dateObj = new Date(problemSet.date);
  const year = dateObj.getFullYear();
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const day = dateObj.getDate().toString().padStart(2, '0');
  problemHeaderDate.textContent = `${year}年${month}月${day}日 更新分`;

  renderProblemButtons();
  setEssay(problemSet.essayStartIndex); 
}
  
  function renderProblemButtons() {
    problemButtonsContainer.innerHTML = ""; // ボタンをクリア

    for (let i = 0; i < currentProblemSetNumProblems; i++) {
      const button = document.createElement("button");
      const essayGlobalIndex = currentProblemSetStartIndex + i;
      button.textContent = `問題${i + 1}`;
      button.style.fontSize = "0.8em";
      button.style.padding = "5px 10px";
      button.onclick = () => setEssay(essayGlobalIndex);
      if (essayGlobalIndex === currentEssayIndex) {
        button.classList.add("active"); // 現在の問題にactiveクラスを付与
      }
      problemButtonsContainer.appendChild(button);
    }
  }

  function setEssay(index) {
    currentEssayIndex = index;
    typingArea.value = "";
    updateDisplay();
    typingArea.focus();
    startTime = null;
    renderProblemButtons(); // ボタンのactive状態を更新するために再描画
  }

  function updateDisplay() {
  // const currentEssay = essays[currentEssayIndex]; // ← 古い行
  const currentEssayText = allEssays[currentEssayIndex]; // ← 新しい行

  if (typeof currentEssayText === 'undefined') {
      display.innerHTML = "問題が選択されていません。";
      // console.warn("updateDisplay: currentEssayText is undefined for index", currentEssayIndex);
      return;
  }
  const input = typingArea.value;
  display.innerHTML = "";
  let errorMarked = false;

  for (let i = 0; i < currentEssayText.length; i++) { // currentEssay を currentEssayText に変更
    const span = document.createElement("span");
    const expected = currentEssayText[i]; // currentEssay を currentEssayText に変更
    const typed = input[i];

    if (i < input.length) {
      if (!errorMarked) {
        if (typed === expected) {
          span.className = "correct";
        } else {
          span.className = "incorrect";
          errorMarked = true;
        }
      } else {
        span.className = "untyped";
      }
    } else {
      span.className = "untyped";
    }

    span.textContent = expected;
    display.appendChild(span);
  }

  if (!errorMarked && input === currentEssayText && currentEssayText.length > 0) { // currentEssay を currentEssayText に変更
    showResult();
  }
}

  function getEvaluationMessage(wpm) {
    if (wpm >= 400) return "You are god.";
    if (wpm >= 300) return "あなたは鍵をもつ風。";
    if (wpm >= 200) return "あなたの言葉は稲妻。世界を貫いている。";
    if (wpm >= 120) return "思考と指先が調和して、美しい旋律を奏でている。";
    if (wpm >= 60) return "確かな歩みが、言葉をひとつずつ紡いでいく。";
    if (wpm >= 30) return "急がず焦らず、言葉と心を結びつける旅の途中。";
    return "複雑に考えず、自分自身でいること。";
  }

  function getLevelComment(wpm) {
    if (wpm >= 400) return "神速の領域。指先で詩を書いているようです。";
    if (wpm >= 300) return "プロフェッショナルの風格。キーボードもあなたに従っている。";
    if (wpm >= 200) return "洗練された速度。タイピングが日常の一部となっている証です。";
    if (wpm >= 120) return "実務でも十分通用します。滑らかな言葉の流れが感じられます。";
    if (wpm >= 60) return "落ち着いたテンポ。着実な力を育んでいます。";
    if (wpm >= 30) return "丁寧さが光っています。正確さは力です。";
    return "始まりの一歩。焦らず、楽しみながら育てていきましょう。";
  }

  function showResult() {
    if (!startTime) return; // startTimeがnullの場合は結果を表示しない
    const elapsed = ((Date.now() - startTime) / 1000); // 秒
    const charCount = typingArea.value.length;
    const wpm = charCount > 0 && elapsed > 0 ? Math.round((charCount / elapsed) * 60) : 0;

    popupList.innerHTML = "";

    const createItem = (label, content) => {
      const li = document.createElement("li");
      li.style.whiteSpace = "nowrap";
      li.style.overflow = "hidden";
      li.style.textOverflow = "ellipsis";
      li.innerHTML = `<strong>${label}</strong> ${content}`;
      return li;
    };

    popupList.appendChild(createItem("所要時間：", `${elapsed.toFixed(1)}秒`));
    popupList.appendChild(createItem("入力文字数：", `${charCount}文字`));
    popupList.appendChild(createItem("WPM：", `${wpm}文字/分　${getLevelComment(wpm)}`));
    popupList.appendChild(createItem("評価：", getEvaluationMessage(wpm)));

    popup.style.display = "block";
    typingArea.blur();
  }

  typingArea.addEventListener("input", () => {
    if (!startTime && typingArea.value.length > 0) { // 入力が開始されたらstartTimeを設定
      startTime = Date.now();
    }
    if (typingArea.value.length === 0) { // 入力がクリアされたらstartTimeをリセット
        startTime = null;
    }
    updateDisplay();
  });

  typingArea.addEventListener("paste", function (event) {
    event.preventDefault();
    alert("ペーストは無効です。");
  });

  document.addEventListener('keydown', function (e) {
  if (popup.style.display === 'block' && (e.key === 'q' || e.key === 'Q')) {
    popup.style.display = 'none';
    // const currentProblemSet = archiveData.find(set => set.essayStartIndex === currentProblemSetStartIndex); // ← 古い行
    const currentProblemSet = archiveStructure.find(set => set.essayStartIndex === currentProblemSetStartIndex); // ← 新しい行
    if (currentProblemSet) {
        const nextProblemInSetIndex = currentEssayIndex + 1;
        if (nextProblemInSetIndex < currentProblemSet.essayStartIndex + currentProblemSet.numProblems) {
            setEssay(nextProblemInSetIndex); 
        } else {
            setEssay(currentProblemSet.essayStartIndex); 
        }
    }
    typingArea.focus();
    e.preventDefault();
  }
});
  //入力フォームの自動調整 (今回は使っていないが、必要であれば)
  // function adjustHeight(element) {
  //   element.style.height = "auto"; // 高さをリセット
  //   element.style.height = element.scrollHeight + "px"; // 自動調整
  // }

// バックナンバーを表示する関数
function renderArchive(archivesToDisplay) { // ← 新しい定義 (引数を追加)
  const archiveList = document.getElementById("archive-list");
  archiveList.innerHTML = ""; 

  // archiveStructure.forEach((entry, problemSetGlobalIndex) => { // ← 古いループ
  archivesToDisplay.forEach((entry, index) => { // ← 新しいループ (引数のデータを使用)
    // problemSetGlobalIndex を entry から取得するか、元の archiveStructure でのインデックスを保持する必要がある。
    // 簡単なのは、archiveStructure 全体から元のインデックスを検索するか、
    // archivesToDisplay に渡す時点で元のインデックス情報も付与すること。
    // ここでは、archiveStructure全体から検索する方法を取ります。
    // ただし、パフォーマンス的にはデータが多いと不利なので、データ構造の工夫も考えられます。
    // よりシンプルなのは、`index` が `archivesToDisplay` 内でのインデックスなので、
    // `setActiveProblemSet` に渡すのは `archiveStructure` 全体でのインデックスである必要がある。
    // `entry` オブジェクト自体は `archiveStructure` の要素なので、`archiveStructure.indexOf(entry)` で元のインデックスを取得可能。
    const problemSetGlobalIndex = archiveStructure.indexOf(entry);

    const dateDiv = document.createElement("div");
    dateDiv.classList.add("archive-entry");

    // ... (以降のdateDivを組み立てる部分は変更なし、ただし setActiveProblemSet に渡すインデックスに注意) ...
    // dateLink.onclick の中の setActiveProblemSet(problemSetGlobalIndex) はそのままでOK
    // titleButton.onclick の中の setActiveProblemSet(problemSetGlobalIndex) もそのままでOK
    const dateElement = document.createElement("p");
    const dateLink = document.createElement("a");
    dateLink.href = "#"; 

    const dateObj = new Date(entry.date);
    const year = dateObj.getFullYear();
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const day = dateObj.getDate().toString().padStart(2, '0');
    dateLink.textContent = `${year}年${month}月${day}日`; 

    dateLink.style.fontWeight = "bold";
    dateLink.style.textDecoration = "none";
    dateLink.style.color = "#333";
    dateLink.onclick = (e) => {
      e.preventDefault();
      setActiveProblemSet(problemSetGlobalIndex); // ここは元の配列でのインデックスを使う
    };
    dateElement.appendChild(dateLink);
    dateDiv.appendChild(dateElement);

    const titleDiv = document.createElement("div");
    titleDiv.classList.add("archive-titles");
    entry.titles.forEach((title, indexInSet) => {
      const titleButton = document.createElement("button");
      titleButton.textContent = title;
      titleButton.onclick = () => {
          setActiveProblemSet(problemSetGlobalIndex); // ここは元の配列でのインデックスを使う
          setEssay(entry.essayStartIndex + indexInSet); 
      };
      titleDiv.appendChild(titleButton);
    });
    dateDiv.appendChild(titleDiv);

    archiveList.appendChild(dateDiv);
  });
}
loadTypingData(); // ← これを新しく追加

  </script>
  
</body>
</html>